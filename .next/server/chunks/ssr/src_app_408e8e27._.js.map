{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IA0GsB,0BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IA8HsB,kCAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAkLsB,yBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IA+NsB,uBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAwPsB,wBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAiSsB,8BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IA0TsB,uBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IA+UsB,iCAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAgWsB,uBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAuYsB,0BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAg9BsB,gCAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAqgBsB,iBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAuhBsB,wBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAwmBsB,0BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAwnBsB,0BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IA+pBsB,wBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAisBsB,2BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAgtBsB,mCAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAywBsB,4BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 254, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAwxBsB,6BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 267, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAm3BsB,8BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 280, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IA66BsB,uBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAm4BsB,yBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport { generateQuestions } from \"@/ai/flows/generate-questions\";\nimport { generateFeedback } from \"@/ai/flows/generate-feedback\";\nimport { generateQuestionsFromFile } from \"@/ai/flows/generate-questions-from-file\";\nimport { generateAdvice } from \"@/ai/flows/generate-advice\";\nimport { generateQuestionPaper } from \"@/ai/flows/generate-question-paper\";\nimport { generateAttendanceReport } from \"@/ai/flows/generate-attendance-report\";\nimport { generateMarkFeedback } from \"@/ai/flows/generate-mark-feedback\";\nimport { gradeAssignment } from \"@/ai/flows/grade-assignment-flow\";\nimport { generateClassroomGame } from \"@/ai/flows/generate-classroom-game\";\nimport { generateKnowledgeGalaxy } from \"@/ai/flows/generate-knowledge-galaxy\";\nimport { checkPlagiarism } from \"@/ai/flows/check-plagiarism\";\nimport { \n    GenerateQuestionsInputSchema,\n    GenerateFeedbackInputSchema,\n    GenerateQuestionsFromFileInputSchema,\n    GenerateAdviceInputSchema,\n    GenerateQuestionPaperInputSchema,\n    GenerateAttendanceReportInputSchema,\n    SaveAttendanceInputSchema,\n    SaveInternalMarksInputSchema,\n    SaveSyllabusTrackerInputSchema,\n    SaveAcademicEventInputSchema,\n    GradeAssignmentInputSchema,\n    ProjectTrackerInputSchema,\n    UploadStudentDocumentInputSchema,\n    GenerateClassroomGameInputSchema,\n    SaveGameScoreInputSchema,\n    GenerateKnowledgeGalaxyInputSchema,\n    CreateCustomQuizInputSchema,\n    LoginSchema,\n    RegisterSchema,\n    PlagiarismCheckInputSchema,\n    type GenerateQuestionsInput, \n    type GenerateFeedbackInput, \n    type GenerateFeedbackOutput,\n    type MCQQuestion,\n    type GenerateQuestionsFromFileInput,\n    type GenerateAdviceOutput,\n    type GenerateQuestionPaperInput,\n    type GenerateQuestionPaperOutput,\n    type GenerateAttendanceReportInput,\n    type GenerateAttendanceReportOutput,\n    type SaveAttendanceInput,\n    type SaveInternalMarksInput,\n    type PerformanceReport,\n    type AttendanceRecord,\n    type SyllabusTrackerRecord,\n    type SaveSyllabusTrackerInput,\n    type TeacherRemarkRecord,\n    type StudentInfo,\n    type StudentProfileData,\n    type AcademicEventRecord,\n    type GradeAssignmentOutput,\n    type ProjectTrackerInput,\n    type ProjectTrackerRecord,\n    type StudentDocumentRecord,\n    type GenerateClassroomGameOutput,\n    type GameLeaderboardRecord,\n    type SaveGameScoreInput,\n    type GenerateKnowledgeGalaxyOutput,\n    type CreateCustomQuizInput,\n    type CustomQuizRecord,\n    type LoginInput,\n    type RegisterInput,\n    type GenerateKnowledgeGalaxyInput,\n    type PlagiarismCheckInput,\n    type PlagiarismCheckOutput,\n} from \"@/ai/schemas\";\nimport { getSupabaseAdmin } from \"@/lib/supabase/admin\";\nimport { createServerClient } from \"@/lib/supabase/server\";\nimport { format } from \"date-fns\";\nimport { revalidatePath } from \"next/cache\";\nimport { redirect } from \"next/navigation\";\nimport { supabase } from \"@/lib/supabase/client\";\nimport mammoth from 'mammoth';\n\n// === Question Actions ===\ntype QuestionActionResponse = {\n  questions?: MCQQuestion[];\n  error?: string;\n};\n\nasync function saveQuestionsToSupabase(questions: MCQQuestion[], topic?: string) {\n    if (!topic || questions.length === 0) return;\n\n    const questionsToInsert = questions.map(q => ({\n        topic: topic,\n        question_text: q.question,\n        option_a: q.options.A,\n        option_b: q.options.B,\n        option_c: q.options.C,\n        option_d: q.options.D,\n        correct_option: q.answer\n    }));\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    const { error } = await supabase.from('mcq_questions').insert(questionsToInsert);\n    if (error) {\n        console.error(\"Error saving questions to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionsAction(input: GenerateQuestionsInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestions(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions:\", error);\n    return { error: \"Failed to generate questions. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nexport async function generateQuestionsFromFileAction(input: GenerateQuestionsFromFileInput): Promise<QuestionActionResponse> {\n  const parsedInput = GenerateQuestionsFromFileInputSchema.safeParse(input);\n\n  if (!parsedInput.success) {\n    console.error(\"Invalid input for question generation from file:\", parsedInput.error.flatten());\n    return { error: \"Invalid input.\" };\n  }\n\n  try {\n    const output = await generateQuestionsFromFile(parsedInput.data);\n    if (output.questions) {\n        saveQuestionsToSupabase(output.questions, parsedInput.data.topic);\n    }\n    return { questions: output.questions };\n  } catch (error) {\n    console.error(\"Error generating questions from file:\", error);\n    return { error: \"Failed to generate questions from the file. The AI model may be unavailable or the request timed out. Please try again later.\" };\n  }\n}\n\nasync function saveFeedbackToSupabase(feedbackData: GenerateFeedbackOutput, input: GenerateFeedbackInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const score = Object.values(input.marks).reduce((sum, mark) => sum + mark, 0);\n    const total = input.subjects.length * 100; // Assuming 100 max marks per subject, consistent with grade-analyzer\n    const subject = input.subjects.join(', ');\n\n    const reportToInsert = {\n      student_name: input.studentName,\n      subject: subject,\n      score: score,\n      total: total,\n      feedback: JSON.stringify({\n          strengths: feedbackData.strengths,\n          weaknesses: feedbackData.weaknesses,\n          improvementTips: feedbackData.improvementTips,\n      }),\n      improvement_plan: JSON.stringify(feedbackData.studyPlan),\n    };\n    \n    const { error } = await supabase.from('performance_reports').insert([reportToInsert]);\n    if (error) {\n        console.error(\"Error saving performance report to Supabase:\", error);\n    }\n}\n\ntype FeedbackActionResponse = {\n    feedback?: GenerateFeedbackOutput;\n    error?: string;\n};\n\nexport async function generateFeedbackAction(input: GenerateFeedbackInput): Promise<FeedbackActionResponse> {\n    const parsedInput = GenerateFeedbackInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        return { error: \"Invalid input for feedback generation.\" };\n    }\n\n    try {\n        const output = await generateFeedback(parsedInput.data);\n        if (output) {\n            await saveFeedbackToSupabase(output, parsedInput.data);\n        }\n        revalidatePath('/');\n        return { feedback: output };\n    } catch (error) {\n        console.error(\"Error generating feedback:\", error);\n        return { error: \"Failed to generate AI feedback. The model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AdviceActionResponse = {\n    advice?: GenerateAdviceOutput;\n    error?: string;\n};\n\nasync function saveAdviceToSupabase(advice: GenerateAdviceOutput, input: { subject?: string; text?: string; fileDataUri?: string }) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n\n    const planToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      uploaded_content: input.fileDataUri || input.text,\n      covered_topics: JSON.stringify(advice.coveredTopics),\n      next_topic: advice.nextTopic,\n      revision_topics: JSON.stringify(advice.suggestedRevisions),\n      missed_concepts: JSON.stringify(advice.skippedConcepts)\n    };\n    \n    const { error } = await supabase.from('teaching_plans').insert([planToInsert]);\n    if (error) {\n        console.error(\"Error saving teaching plan to Supabase:\", error);\n    }\n}\n\nexport async function generateAdviceAction(input: { subject?: string; text?: string; fileDataUri?: string }): Promise<AdviceActionResponse> {\n    const parsedInput = GenerateAdviceInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for advice generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAdvice(parsedInput.data);\n        if (output) {\n            saveAdviceToSupabase(output, parsedInput.data);\n        }\n        return { advice: output };\n    } catch (error) {\n        console.error(\"Error generating advice:\", error);\n        return { error: \"Failed to generate teaching advice. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype ReportActionResponse = {\n    reports?: PerformanceReport[];\n    error?: string;\n}\n\nexport async function getPerformanceReports(): Promise<ReportActionResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { data, error } = await supabase\n      .from(\"performance_reports\")\n      .select(\"*\")\n      .order(\"created_at\", { ascending: false });\n\n    if (error) {\n        console.error(\"Error fetching performance reports:\", error);\n        return { error: \"Could not fetch performance reports. Please ensure the 'performance_reports' table exists and that your Supabase credentials are correct.\" };\n    }\n\n    return { reports: data as PerformanceReport[] };\n}\n\ntype QuestionPaperActionResponse = {\n    paper?: GenerateQuestionPaperOutput;\n    error?: string;\n};\n\nasync function saveQuestionPaperToSupabase(paper: GenerateQuestionPaperOutput, input: GenerateQuestionPaperInput) {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return;\n    \n    const paperToInsert = {\n      teacher_id: null, // No user to associate with\n      subject: input.subject,\n      unit: input.unit || `File: ${new Date().toISOString()}`,\n      one_mark: paper.oneMarkQuestions,\n      two_mark: paper.twoMarkQuestions,\n      ten_mark: paper.tenMarkQuestions,\n    };\n\n    const { error } = await supabase.from('question_papers_v2').insert([paperToInsert]);\n    if (error) {\n        console.error(\"Error saving question paper to Supabase:\", error);\n    }\n}\n\nexport async function generateQuestionPaperAction(input: GenerateQuestionPaperInput): Promise<QuestionPaperActionResponse> {\n    const parsedInput = GenerateQuestionPaperInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for question paper generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateQuestionPaper(parsedInput.data);\n        if (output) {\n            saveQuestionPaperToSupabase(output, parsedInput.data);\n        }\n        return { paper: output };\n    } catch (error) {\n        console.error(\"Error generating question paper:\", error);\n        return { error: \"Failed to generate the question paper. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\ntype AttendanceResponse = {\n    records?: AttendanceRecord[];\n    error?: string;\n};\n\nexport async function getAttendanceRecords(): Promise<AttendanceResponse> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('*')\n        .order('date', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching attendance records:', error);\n        return { error: \"Could not fetch attendance data. Please ensure the 'student_attendance' table exists.\" };\n    }\n\n    return { records: data as AttendanceRecord[] };\n}\n\ntype AttendanceReportActionResponse = {\n    report?: GenerateAttendanceReportOutput;\n    error?: string;\n};\n\nexport async function generateAttendanceReportAction(input: GenerateAttendanceReportInput): Promise<AttendanceReportActionResponse> {\n    const parsedInput = GenerateAttendanceReportInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for attendance report generation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await generateAttendanceReport(parsedInput.data);\n        return { report: output };\n    } catch (error) {\n        console.error(\"Error generating attendance report:\", error);\n        return { error: \"Failed to generate attendance report. The AI model may be unavailable or the request timed out.\" };\n    }\n}\n\nexport async function saveAttendanceAction(input: SaveAttendanceInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAttendanceInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { data } = parsedInput;\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        \n    const record = {\n        student_name: data.student_name,\n        roll_no: data.roll_no,\n        date: data.date, \n        subject: data.subject,\n        period: data.period,\n        status: data.status,\n        remark: data.remark || null,\n        behavior_tags: data.behavior_tags || null,\n    };\n    \n    const { error } = await supabase\n        .from('student_attendance')\n        .insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting attendance:\", error);\n        return { error: \"Could not save attendance data due to a database error.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Saved attendance for ${data.student_name} (${data.period}) — ${data.status} on ${data.date}`};\n}\n\ntype MarkCalculatorActionResponse = {\n    feedback?: string;\n    error?: string;\n};\n\nexport async function saveInternalMarksAction(input: SaveInternalMarksInput): Promise<MarkCalculatorActionResponse> {\n    const parsedInput = SaveInternalMarksInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for mark calculation:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    const { student_name, roll_no, subject, test1, test2, assignment, attendance } = parsedInput.data;\n    \n    const internal_score = test1 + test2 + assignment;\n    \n    let grade = 'F';\n    if (internal_score >= 27) grade = 'A+';\n    else if (internal_score >= 24) grade = 'A';\n    else if (internal_score >= 21) grade = 'B';\n    else if (internal_score >= 18) grade = 'C';\n    else if (internal_score >= 15) grade = 'D';\n\n    try {\n        // Generate AI feedback\n        const feedbackResult = await generateMarkFeedback({\n            studentName: student_name,\n            internalScore: internal_score,\n            grade: grade,\n            attendance: attendance,\n        });\n\n        if (!feedbackResult.feedback) {\n            throw new Error(\"AI failed to generate feedback.\");\n        }\n\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        // Save to Supabase\n        const recordToInsert = {\n            student_name,\n            roll_no,\n            subject,\n            test1,\n            test2,\n            assignment,\n            attendance,\n            internal_score,\n            grade,\n            feedback: feedbackResult.feedback,\n        };\n        \n        const { error: dbError } = await supabase.from('internal_marks').insert([recordToInsert]);\n\n        if (dbError) {\n            console.error(\"Error saving internal marks to Supabase:\", dbError);\n            throw new Error(\"Failed to save the record to the database.\");\n        }\n        revalidatePath('/');\n        return { feedback: feedbackResult.feedback };\n    } catch (error) {\n        console.error(\"Error in saveInternalMarksAction:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred during feedback generation or saving.\";\n        return { error: errorMessage };\n    }\n}\n\nexport async function getSyllabusTrackerRecords(): Promise<{ records?: SyllabusTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const { data, error } = await supabase\n        .from('syllabus_tracker')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching syllabus tracker records:', error);\n        return { error: \"Could not fetch syllabus tracker data. Please check your RLS policies.\" };\n    }\n\n    return { records: data };\n}\n\nexport async function saveSyllabusTrackerAction(input: SaveSyllabusTrackerInput): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n\n    const parsedInput = SaveSyllabusTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input.\" };\n    }\n    \n    const { subject, topic } = parsedInput.data;\n    \n    const record = {\n        subject: subject,\n        topic: topic,\n        completed: false, // Always false on creation\n        uploaded_by: null, // No user to associate with\n    };\n    \n    const { error } = await supabase.from('syllabus_tracker').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting syllabus topic:\", error);\n        return { error: \"Could not save syllabus data due to a database error.\" };\n    }\n    revalidatePath('/');\n    return { message: `Added topic \"${topic}\" to ${subject}.`};\n}\n\nexport async function updateSyllabusTopicStatusAction(id: string, completed: boolean): Promise<{ message?: string, error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    \n    const { error } = await supabase\n        .from('syllabus_tracker')\n        .update({ completed })\n        .eq('id', id);\n\n    if (error) {\n        console.error(\"Error updating syllabus topic:\", error);\n        return { error: \"Could not update topic status.\" };\n    }\n    revalidatePath('/');\n    return { message: \"Topic status updated.\" };\n}\n\n\nexport async function getStudentList(): Promise<{ students?: StudentInfo[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('student_attendance')\n        .select('student_name, roll_no')\n        .order('student_name', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching student list:', error);\n        return { error: 'Could not fetch student list.' };\n    }\n\n    const uniqueStudents = Array.from(new Map(data.map(item => [item.roll_no, item])).values());\n    \n    return { students: uniqueStudents };\n}\n\nexport async function getStudentProfileData(rollNo: string): Promise<{ profile?: StudentProfileData, error?: string }> {\n    try {\n        const supabase = getSupabaseAdmin();\n        if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n        const { data: attendanceData, error: attendanceError } = await supabase\n            .from('student_attendance')\n            .select('status, behavior_tags')\n            .eq('roll_no', rollNo);\n        if (attendanceError) throw new Error(`Attendance fetch failed: ${attendanceError.message}`);\n\n        const totalDays = attendanceData.length;\n        const presentDays = attendanceData.filter(r => r.status === 'Present' || r.status === 'Late').length;\n        const attendancePercentage = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : 0;\n        \n        const behaviorTags = [...new Set(\n            attendanceData\n                .flatMap(r => (r.behavior_tags ? r.behavior_tags.split(',').map(tag => tag.trim()) : []))\n                .filter(Boolean)\n        )];\n        \n        const { data: marksData, error: marksError } = await supabase\n            .from('internal_marks')\n            .select('subject, internal_score, grade, student_name')\n            .eq('roll_no', rollNo);\n        if (marksError) throw new Error(`Marks fetch failed: ${marksError.message}`);\n\n        const { data: remarksData, error: remarksError } = await supabase\n            .from('teacher_remarks')\n            .select('*')\n            .eq('roll_no', rollNo)\n            .order('created_at', { ascending: false });\n        if (remarksError) throw new Error(`Remarks fetch failed: ${remarksError.message}`);\n\n        const studentName = marksData?.[0]?.student_name || attendanceData?.[0]?.student_name || 'N/A';\n\n        const { data: feedbackData, error: feedbackError } = await supabase\n            .from('performance_reports')\n            .select('feedback')\n            .eq('student_name', studentName)\n            .order('created_at', { ascending: false })\n            .limit(1)\n            .single();\n        \n        let aiFeedback = null;\n        if (feedbackData?.feedback) {\n            try {\n                const parsedFeedback = typeof feedbackData.feedback === 'string' ? JSON.parse(feedbackData.feedback) : feedbackData.feedback;\n                aiFeedback = parsedFeedback.improvementTips || \"No specific tips available.\";\n            } catch (e) {\n                aiFeedback = \"Could not parse AI feedback.\";\n            }\n        }\n\n        const profile: StudentProfileData = {\n            studentName,\n            rollNo: rollNo,\n            attendance: {\n                percentage: attendancePercentage,\n                presentDays: presentDays,\n                totalDays: totalDays,\n            },\n            behaviorTags: behaviorTags,\n            marks: marksData.map(m => ({\n                subject: m.subject,\n                internal_score: m.internal_score,\n                grade: m.grade\n            })),\n            remarks: remarksData as TeacherRemarkRecord[],\n            aiFeedback: aiFeedback,\n        };\n\n        return { profile };\n\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred fetching profile data.\";\n        console.error(\"Error in getStudentProfileData:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\nexport async function getAcademicEventsAction(): Promise<{ events?: AcademicEventRecord[], error?: string }> {\n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabaseAdmin\n        .from('academic_calendar')\n        .select('*')\n        .order('event_date', { ascending: true });\n\n    if (error) {\n        console.error('Error fetching academic events:', error);\n        return { error: \"Could not fetch academic events data.\" };\n    }\n\n    return { events: data };\n}\n\nexport async function saveAcademicEventAction(\n    input: Omit<AcademicEventRecord, 'id' | 'created_at' | 'posted_by' | 'event_date'> & { event_date: Date }\n): Promise<{ message?: string, error?: string }> {\n    const parsedInput = SaveAcademicEventInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input. \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n    \n    const { title, description, event_date, event_type } = parsedInput.data;\n    \n    const formattedDate = format(event_date, 'yyyy-MM-dd');\n    \n    const record = {\n        title,\n        description: description || null,\n        event_date: formattedDate,\n        event_type,\n        posted_by: null // No user to associate with\n    };\n    \n    const supabaseAdmin = getSupabaseAdmin();\n    if (!supabaseAdmin) return { error: \"Could not create Supabase admin client.\" };\n    const { error } = await supabaseAdmin.from('academic_calendar').insert([record]);\n            \n    if (error) {\n        console.error(\"Error inserting academic event:\", error);\n        return { error: \"Could not insert new event record.\" };\n    }\n    \n    revalidatePath('/');\n\n    return { message: `Successfully added event: \"${title}\"`};\n}\n\ntype GradeAssignmentActionResponse = {\n    result?: GradeAssignmentOutput;\n    error?: string;\n};\n\nexport async function gradeAssignmentAction(input: { studentName: string; subject: string; fileDataUri: string }): Promise<GradeAssignmentActionResponse> {\n    const parsedInput = GradeAssignmentInputSchema.safeParse(input);\n\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for assignment grading:\", parsedInput.error.flatten());\n        return { error: \"Invalid input.\" };\n    }\n\n    try {\n        const output = await gradeAssignment(parsedInput.data);\n        if (output) {\n            // Save to Supabase\n            const supabase = getSupabaseAdmin();\n            if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n            const { error } = await supabase.from('assignment_scores').insert([{\n                student_name: parsedInput.data.studentName,\n                subject: parsedInput.data.subject,\n                score: output.score,\n                feedback: output.feedback,\n            }]);\n\n            if (error) {\n                console.error(\"Error saving assignment score to Supabase:\", error);\n                throw new Error(\"Failed to save the grading result to the database.\");\n            }\n        }\n        revalidatePath('/');\n        return { result: output };\n    } catch (error) {\n        console.error(\"Error grading assignment:\", error);\n        return { error: \"Failed to grade the assignment. The AI model may be unavailable or the request timed out. Please try again.\" };\n    }\n}\n\nexport async function getProjectTrackerRecords(): Promise<{ records?: ProjectTrackerRecord[], error?: string }> {\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    const { data, error } = await supabase\n        .from('project_tracker')\n        .select('*')\n        .order('updated_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching project tracker records:', error);\n        return { error: \"Could not fetch project tracker data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveOrUpdateProjectTrackerAction(input: ProjectTrackerInput): Promise<{ message?: string, error?: string }> {\n    const parsedInput = ProjectTrackerInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        return { error: \"Invalid input: \" + parsedInput.error.flatten().formErrors.join(', ') };\n    }\n\n    const { id, roll_no, ...recordData } = parsedInput.data;\n    \n    const recordToSave = { roll_no, ...recordData };\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not create Supabase admin client.\" };\n    if (id) {\n        const { error } = await supabase\n            .from('project_tracker')\n            .update(recordToSave)\n            .eq('id', id);\n\n        if (error) {\n            console.error(\"Error updating project:\", error);\n            return { error: \"Could not update project record.\" };\n        }\n        revalidatePath('/');\n        return { message: `Updated project for ${recordToSave.student_name}.` };\n    }\n    \n    const { data: existing, error: selectError } = await supabase\n        .from('project_tracker')\n        .select('id')\n        .eq('roll_no', roll_no)\n        .limit(1)\n        .single();\n    \n    if (selectError && selectError.code !== 'PGRST116') {\n        console.error(\"DB error checking for duplicates:\", selectError);\n        return { error: \"Database error.\" };\n    }\n    \n    if (existing) {\n        return { error: `A project for Roll No. ${roll_no} already exists.` };\n    }\n\n    const { error: insertError } = await supabase\n        .from('project_tracker')\n        .insert([recordToSave]);\n        \n    if (insertError) {\n        console.error(\"Error inserting project:\", insertError);\n        return { error: \"Could not insert new project record.\" };\n    }\n    \n    revalidatePath('/');\n    return { message: `Added project for ${recordToSave.student_name}.` };\n}\n\n// === Student Document Vault Actions ===\n\n// Get all documents for the teacher view\nexport async function getStudentDocumentsAction(): Promise<{ records?: StudentDocumentRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .select('*')\n        .order('uploaded_at', { ascending: false });\n\n    if (error) {\n        console.error('Error fetching student documents:', error.message);\n        return { error: \"Could not fetch student documents. Please check your Supabase SELECT policy on the 'student_documents' table.\" };\n    }\n    return { records: data };\n}\n\n// Verify or un-verify a document\nexport async function updateDocumentStatusAction(documentId: string, verified: boolean): Promise<{ record?: StudentDocumentRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('student_documents')\n        .update({ verified })\n        .eq('id', documentId)\n        .select()\n        .single();\n\n    if (error) {\n        console.error('Error updating document status:', error);\n        return { error: \"Could not update document status.\" };\n    }\n    revalidatePath('/');\n    return { record: data };\n}\n\n// Upload a new document\nexport async function uploadStudentDocumentAction(formData: FormData): Promise<{ message?: string, error?: string }> {\n    const rawData = {\n        student_name: formData.get('student_name'),\n        roll_no: formData.get('roll_no'),\n        doc_type: formData.get('doc_type'),\n    };\n    \n    const parsedInput = UploadStudentDocumentInputSchema.safeParse(rawData);\n    if (!parsedInput.success) {\n        const firstError = parsedInput.error.errors[0]?.message || 'Invalid input.';\n        return { error: firstError };\n    }\n\n    const file = formData.get('file') as File;\n    if (!file || file.size === 0) {\n        return { error: 'File is required.' };\n    }\n    if (file.size > 5 * 1024 * 1024) { // 5MB limit\n        return { error: 'File size must be less than 5MB.' };\n    }\n\n    try {\n        const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.\\-_]/g, '_');\n        const basePath = 'public';\n        const filePath = `${basePath}/${parsedInput.data.roll_no}/${Date.now()}-${sanitizedFileName}`;\n\n        const BUCKET_NAME = 'student-documents';\n        const supabase = createServerClient();\n\n        const { error: uploadError } = await supabase.storage\n            .from(BUCKET_NAME)\n            .upload(filePath, file);\n\n        if (uploadError) {\n            console.error('Supabase Storage Upload Error:', uploadError);\n            throw new Error(`Storage error: ${uploadError.message}. Please ensure the bucket '${BUCKET_NAME}' exists and has the correct policies.`);\n        }\n\n        const { data: urlData } = supabase.storage\n            .from(BUCKET_NAME)\n            .getPublicUrl(filePath);\n\n        if (!urlData.publicUrl) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(\"Could not get public URL for the uploaded file.\");\n        }\n\n        const recordToInsert = {\n            ...parsedInput.data,\n            file_path: filePath,\n            file_url: urlData.publicUrl,\n            uploaded_by: 'student', // No user context\n            verified: false,\n        };\n\n        const { error: insertError } = await supabase.from('student_documents').insert([recordToInsert]);\n\n        if (insertError) {\n            await supabase.storage.from(BUCKET_NAME).remove([filePath]);\n            throw new Error(`Database error: ${insertError.message}`);\n        }\n        revalidatePath('/upload');\n        revalidatePath('/');\n        return { message: \"Document uploaded successfully! It will be reviewed by your teacher.\" };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred during upload.\";\n        console.error(\"Upload failed:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n// === Classroom Gamifier Actions ===\n\nexport async function generateClassroomGameAction(\n    topic: string\n): Promise<{ game?: GenerateClassroomGameOutput, error?: string }> {\n    const parsedInput = GenerateClassroomGameInputSchema.safeParse({ topic });\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const gameData = await generateClassroomGame(parsedInput.data);\n        return { game: gameData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateClassroomGameAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\nexport async function createCustomQuizAction(input: CreateCustomQuizInput): Promise<{ quizId?: string, error?: string }> {\n    const parsedInput = CreateCustomQuizInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .insert({\n            topic: parsedInput.data.topic,\n            questions: JSON.stringify(parsedInput.data.questions),\n            created_by: null, // No auth\n        })\n        .select('id')\n        .single();\n    \n    if (error) {\n        console.error(\"Error creating custom quiz:\", error);\n        return { error: \"Failed to save the quiz to the database.\" };\n    }\n    \n    revalidatePath('/');\n    return { quizId: data.id };\n}\n\nexport async function getQuizAction(id: string): Promise<{ quiz?: CustomQuizRecord, error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('custom_quizzes')\n        .select('*')\n        .eq('id', id)\n        .single();\n    \n    if (error) {\n        console.error(`Error fetching quiz ${id}:`, error);\n        return { error: \"Could not find the requested quiz.\" };\n    }\n    return { quiz: data };\n}\n\n\nexport async function getLeaderboardAction(topic: string): Promise<{ records?: GameLeaderboardRecord[], error?: string }> {\n    const supabase = createServerClient();\n    const { data, error } = await supabase\n        .from('gamification_leaderboard')\n        .select('*')\n        .eq('topic', topic)\n        .order('score', { ascending: false })\n        .limit(10);\n\n    if (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        return { error: \"Could not fetch leaderboard data.\" };\n    }\n    return { records: data };\n}\n\nexport async function saveGameScoreAction(input: SaveGameScoreInput): Promise<{ success?: boolean, error?: string }> {\n    const parsedInput = SaveGameScoreInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n    \n    const supabase = getSupabaseAdmin();\n    if (!supabase) return { error: \"Could not connect to the database.\" };\n\n    const { error } = await supabase.from('gamification_leaderboard').insert([parsedInput.data]);\n    if (error) {\n        console.error(\"Error saving score:\", error);\n        return { error: \"Failed to save score.\" };\n    }\n    revalidatePath('/');\n    return { success: true };\n}\n\n\n// === Knowledge Galaxy Actions ===\n\nexport async function generateKnowledgeGalaxyAction(\n    input: GenerateKnowledgeGalaxyInput,\n): Promise<{ galaxy?: GenerateKnowledgeGalaxyOutput, error?: string }> {\n    const parsedInput = GenerateKnowledgeGalaxyInputSchema.safeParse(input);\n    if (!parsedInput.success) return { error: \"Invalid input.\" };\n\n    try {\n        const galaxyData = await generateKnowledgeGalaxy(parsedInput.data);\n        if (!galaxyData || !galaxyData.subject) {\n            // Add a subject if the AI didn't provide one (e.g., from a file)\n            const fallbackSubject = input.subject || \"Uploaded Syllabus\";\n            return { galaxy: { ...galaxyData, subject: fallbackSubject } };\n        }\n        return { galaxy: galaxyData };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : \"An unknown error occurred.\";\n        console.error(\"Error in generateKnowledgeGalaxyAction:\", errorMessage);\n        return { error: errorMessage };\n    }\n}\n\n\n// === Plagiarism Checker Actions ===\n\nasync function getFileContentAsDataUri(fileContent: string, mimeType: string): Promise<string> {\n    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {\n        const buffer = Buffer.from(fileContent.split(',')[1], 'base64');\n        const { value } = await mammoth.extractRawText({ buffer });\n        return `data:text/plain;base64,${Buffer.from(value).toString('base64')}`;\n    }\n    // For PDF and TXT, the content is already a valid data URI\n    return fileContent;\n}\n\nexport async function checkPlagiarismAction(input: PlagiarismCheckInput): Promise<{ result?: PlagiarismCheckOutput, error?: string }> {\n    const parsedInput = PlagiarismCheckInputSchema.safeParse(input);\n    if (!parsedInput.success) {\n        console.error(\"Invalid input for plagiarism check:\", parsedInput.error.flatten());\n        return { error: \"Invalid input format for AI model.\" };\n    }\n\n    try {\n        const [doc1DataUri, doc2DataUri] = await Promise.all([\n            getFileContentAsDataUri(parsedInput.data.doc1Content, parsedInput.data.doc1MimeType),\n            getFileContentAsDataUri(parsedInput.data.doc2Content, parsedInput.data.doc2MimeType)\n        ]);\n\n        const flowInput = {\n            ...parsedInput.data,\n            doc1Content: doc1DataUri,\n            doc2Content: doc2DataUri,\n        };\n      \n        const result = await checkPlagiarism(flowInput);\n        return { result };\n\n    } catch (e) {\n      const errorMessage = e instanceof Error ? e.message : \"Failed to run plagiarism check. The AI model may be busy.\";\n      console.error(\"Error in checkPlagiarismAction:\", errorMessage);\n      return { error: errorMessage };\n    }\n}\n\n\n// === Auth Actions ===\nexport async function loginAction(input: LoginInput): Promise<{ error?: string }> {\n    redirect('/');\n    return {};\n}\n\nexport async function registerAction(input: RegisterInput): Promise<{ error?: string, success?: boolean }> {\n    redirect('/');\n    return { success: true };\n}\n\n\nexport async function signOutAction(): Promise<void> {\n    redirect('/');\n}\n"],"names":[],"mappings":";;;;;;IAk/BsB,wBAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 319, "column": 0}, "map": {"version":3,"sources":["file:///C:/Downloads/EduBuddy-main/EduBuddy-main/src/app/page.tsx"],"sourcesContent":["\n\"use client\";\n\nimport { useState } from \"react\";\nimport { motion } from \"framer-motion\";\nimport { QuestionGenerator } from \"@/components/question-generator\";\nimport { GradeAnalyzer } from \"@/components/grade-analyzer\";\nimport { TeachingPlanAdvisor } from \"@/components/teaching-plan-advisor\";\nimport { PerformanceDashboard } from \"@/components/performance-dashboard\";\nimport { QuestionPaperGenerator } from \"@/components/question-paper-generator\";\nimport { AttendanceTracker } from \"@/components/attendance-tracker\";\nimport { MarkCalculator } from \"@/components/mark-calculator\";\nimport { KnowledgeGalaxy } from \"@/components/knowledge-galaxy\";\nimport { StudentProfile } from \"@/components/student-profile\";\nimport { AcademicCalendar } from \"@/components/academic-calendar\";\nimport { AssignmentGrader } from \"@/components/assignment-grader\";\nimport { ProjectTracker } from \"@/components/project-tracker\";\nimport { DocumentVault } from \"@/components/document-vault\";\nimport { ClassroomGamifier } from \"@/components/classroom-gamifier\";\nimport { PlagiarismChecker } from \"@/components/plagiarism-checker\";\nimport { MainNavigation } from \"@/components/main-navigation\";\nimport { Button } from \"@/components/ui/button\";\nimport { ArrowLeft } from \"lucide-react\";\nimport { LampContainer } from \"@/components/ui/lamp\";\n\nconst componentMap: { [key: string]: React.ComponentType } = {\n  \"student-profile\": StudentProfile,\n  \"academic-calendar\": AcademicCalendar,\n  \"gamifier\": ClassroomGamifier,\n  \"document-vault\": DocumentVault,\n  \"question-generator\": QuestionGenerator,\n  \"question-paper-generator\": QuestionPaperGenerator,\n  \"assignment-grader\": AssignmentGrader,\n  \"project-tracker\": ProjectTracker,\n  \"grade-analyzer\": GradeAnalyzer,\n  \"teaching-plan-advisor\": TeachingPlanAdvisor,\n  \"report-dashboard\": PerformanceDashboard,\n  \"attendance-tracker\": AttendanceTracker,\n  \"mark-calculator\": MarkCalculator,\n  \"knowledge-galaxy\": KnowledgeGalaxy,\n  \"plagiarism-checker\": PlagiarismChecker,\n};\n\ntype ViewState = 'welcome' | 'hub' | 'feature';\n\nexport default function Home() {\n  const [viewState, setViewState] = useState<ViewState>('welcome');\n  const [activeTab, setActiveTab] = useState<string | null>(null);\n\n  const ActiveComponent = activeTab ? componentMap[activeTab] : null;\n\n  const handleNodeClick = (tab: string) => {\n    setActiveTab(tab);\n    setViewState('feature');\n  }\n\n  const renderContent = () => {\n    switch (viewState) {\n      case 'welcome':\n        return (\n          <LampContainer>\n            <motion.h1\n              initial={{ opacity: 0.5, y: 100 }}\n              whileInView={{ opacity: 1, y: 0 }}\n              transition={{\n                delay: 0.3,\n                duration: 0.8,\n                ease: \"easeInOut\",\n              }}\n              className=\"bg-gradient-to-br from-blue-300 to-violet-500 bg-clip-text py-4 text-center text-4xl font-medium tracking-tight text-transparent md:text-7xl\"\n            >\n              EduBuddy AI\n            </motion.h1>\n             <motion.p \n                initial={{ opacity: 0, y: 40 }}\n                whileInView={{ opacity: 1, y: 0 }}\n                transition={{\n                    delay: 0.5,\n                    duration: 0.8,\n                    ease: \"easeInOut\",\n                }}\n                className=\"mt-4 text-lg text-center text-slate-400 max-w-lg\"\n             >\n                Your AI-powered toolkit for teaching excellence.\n            </motion.p>\n            <motion.div\n                initial={{ opacity: 0, y: 60 }}\n                whileInView={{ opacity: 1, y: 0 }}\n                transition={{\n                    delay: 0.7,\n                    duration: 0.8,\n                    ease: \"easeInOut\",\n                }}\n                animate={{\n                    y: [0, -8, 0],\n                }}\n                className=\"mt-8\"\n            >\n                <Button\n                    variant=\"outline\"\n                    size=\"lg\"\n                    onClick={() => setViewState('hub')}\n                    className=\"bg-transparent text-white border-white/50 hover:bg-white/10 hover:text-white\"\n                >\n                    Get Started\n                </Button>\n            </motion.div>\n          </LampContainer>\n        );\n\n      case 'hub':\n        return <MainNavigation setActiveTab={handleNodeClick} />;\n\n      case 'feature':\n        return (\n          <main className=\"flex-1 p-4 sm:p-6 md:p-8\">\n            <Button variant=\"outline\" size=\"sm\" onClick={() => setViewState('hub')} className=\"absolute top-4 left-4 z-20\">\n              <ArrowLeft className=\"h-4 w-4 mr-2\" />\n              Back to Hub\n            </Button>\n            {ActiveComponent && <ActiveComponent />}\n          </main>\n        );\n\n      default:\n        return null;\n    }\n  }\n\n  return (\n    <div className=\"flex min-h-screen w-full bg-slate-950 text-slate-50\">\n      {renderContent()}\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;;;;;;;;;;;;;;;;;;;;;;;AAwBA,MAAM,eAAuD;IAC3D,mBAAmB,wIAAA,CAAA,iBAAc;IACjC,qBAAqB,0IAAA,CAAA,mBAAgB;IACrC,YAAY,2IAAA,CAAA,oBAAiB;IAC7B,kBAAkB,uIAAA,CAAA,gBAAa;IAC/B,sBAAsB,2IAAA,CAAA,oBAAiB;IACvC,4BAA4B,oJAAA,CAAA,yBAAsB;IAClD,qBAAqB,0IAAA,CAAA,mBAAgB;IACrC,mBAAmB,wIAAA,CAAA,iBAAc;IACjC,kBAAkB,uIAAA,CAAA,gBAAa;IAC/B,yBAAyB,iJAAA,CAAA,sBAAmB;IAC5C,oBAAoB,8IAAA,CAAA,uBAAoB;IACxC,sBAAsB,2IAAA,CAAA,oBAAiB;IACvC,mBAAmB,wIAAA,CAAA,iBAAc;IACjC,oBAAoB,yIAAA,CAAA,kBAAe;IACnC,sBAAsB,2IAAA,CAAA,oBAAiB;AACzC;AAIe,SAAS;IACtB,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAa;IACtD,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAiB;IAE1D,MAAM,kBAAkB,YAAY,YAAY,CAAC,UAAU,GAAG;IAE9D,MAAM,kBAAkB,CAAC;QACvB,aAAa;QACb,aAAa;IACf;IAEA,MAAM,gBAAgB;QACpB,OAAQ;YACN,KAAK;gBACH,qBACE,8OAAC,gIAAA,CAAA,gBAAa;;sCACZ,8OAAC,0LAAA,CAAA,SAAM,CAAC,EAAE;4BACR,SAAS;gCAAE,SAAS;gCAAK,GAAG;4BAAI;4BAChC,aAAa;gCAAE,SAAS;gCAAG,GAAG;4BAAE;4BAChC,YAAY;gCACV,OAAO;gCACP,UAAU;gCACV,MAAM;4BACR;4BACA,WAAU;sCACX;;;;;;sCAGA,8OAAC,0LAAA,CAAA,SAAM,CAAC,CAAC;4BACN,SAAS;gCAAE,SAAS;gCAAG,GAAG;4BAAG;4BAC7B,aAAa;gCAAE,SAAS;gCAAG,GAAG;4BAAE;4BAChC,YAAY;gCACR,OAAO;gCACP,UAAU;gCACV,MAAM;4BACV;4BACA,WAAU;sCACZ;;;;;;sCAGF,8OAAC,0LAAA,CAAA,SAAM,CAAC,GAAG;4BACP,SAAS;gCAAE,SAAS;gCAAG,GAAG;4BAAG;4BAC7B,aAAa;gCAAE,SAAS;gCAAG,GAAG;4BAAE;4BAChC,YAAY;gCACR,OAAO;gCACP,UAAU;gCACV,MAAM;4BACV;4BACA,SAAS;gCACL,GAAG;oCAAC;oCAAG,CAAC;oCAAG;iCAAE;4BACjB;4BACA,WAAU;sCAEV,cAAA,8OAAC,kIAAA,CAAA,SAAM;gCACH,SAAQ;gCACR,MAAK;gCACL,SAAS,IAAM,aAAa;gCAC5B,WAAU;0CACb;;;;;;;;;;;;;;;;;YAOX,KAAK;gBACH,qBAAO,8OAAC,wIAAA,CAAA,iBAAc;oBAAC,cAAc;;;;;;YAEvC,KAAK;gBACH,qBACE,8OAAC;oBAAK,WAAU;;sCACd,8OAAC,kIAAA,CAAA,SAAM;4BAAC,SAAQ;4BAAU,MAAK;4BAAK,SAAS,IAAM,aAAa;4BAAQ,WAAU;;8CAChF,8OAAC,gNAAA,CAAA,YAAS;oCAAC,WAAU;;;;;;gCAAiB;;;;;;;wBAGvC,iCAAmB,8OAAC;;;;;;;;;;;YAI3B;gBACE,OAAO;QACX;IACF;IAEA,qBACE,8OAAC;QAAI,WAAU;kBACZ;;;;;;AAGP","debugId":null}}]
}